#region Header
/*	============================================
 *	작성자 : Strix
 *	작성일 : 2018-05-12 오후 12:29:48
 *	기능 : 
   ============================================ */
#endregion Header

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class CPlatformerCalculator : CRaycastCalculator
{
    /* const & readonly declaration             */

    /* enum & struct declaration                */

    public enum ECollisionIgnoreType
    {
        None,
        Though_Up,
        Though_Down,
    }

    [System.Serializable]
    public struct CollisionInfo
    {
        public bool above;
        public bool below;
        public bool left, right;

        public bool climbingSlope;
        public bool descendingSlope;
        public bool slidingDownMaxSlope { get; private set; }

        public float slopeAngle, slopeAngleOld;
        public Vector2 slopeNormal;
        public Vector2 moveAmountOld;
        public int iFaceDir_OneIsLeft { get; private set; }
        public bool fallingThroughPlatform;

        public List<Transform> _listHitTransform;

        public void Reset()
        {
            above = below = false;
            left = right = false;
            climbingSlope = false;
            descendingSlope = false;
            DoSetSlopeSliding(false);
            slopeNormal = Vector2.zero;

            slopeAngleOld = slopeAngle;
            slopeAngle = 0;

            _listHitTransform.Clear();
        }

        System.Action<bool> _OnChangeBelow;
        System.Action<int> _OnChangeFaceDir;
        System.Action<bool> _OnChangeSlopeSliding;

        public void DoSet_OnChangeSlopeSliding(System.Action<bool> OnChangeSlopeSliding)
        {
            this._OnChangeSlopeSliding = OnChangeSlopeSliding;
        }

        public void DoSet_OnChangeFaceDir(System.Action<int> OnChangeFaceDir)
        {
            this._OnChangeFaceDir = OnChangeFaceDir;
        }

        public void DoSetSlopeSliding(bool bSliding)
        {
            if (slidingDownMaxSlope != bSliding)
            {
                if (_OnChangeSlopeSliding != null)
                    _OnChangeSlopeSliding(bSliding);

                slidingDownMaxSlope = bSliding;
            }
        }

        public void DoSetFaceDir_OneIsLeft(int iFaceDir)
        {
            if (iFaceDir_OneIsLeft != iFaceDir)
            {
                if (_OnChangeFaceDir != null)
                    _OnChangeFaceDir(iFaceDir);

                iFaceDir_OneIsLeft = iFaceDir;
            }
        }
    }

    /* public - Field declaration            */

    public delegate void OnHit_VerticalCollider(Transform pTransformHit, out ECollisionIgnoreType eIgnnore_ThisHitInfo);

    public bool bDebugMode;

    public LayerMask collisionMask;

    [Rename_Inspector("처음 바라보는 방향")]
    public int p_iFaceDir_OnAwake = 1;
    public float maxSlopeAngle = 80;

    public CollisionInfo p_pCollisionInfo;
    [HideInInspector]
    public Vector2 playerInput;

    public int _iHorizontalHitCount { get; private set; }
    public int _iVerticalHitCount { get; private set; }

    /* protected & private - Field declaration         */

    System.Action<bool> _OnChangeStandOnPlatform;
    OnHit_VerticalCollider _OnHit_VerticalCollider;
    float _fSlopeAngle_Last;
    bool _bIsStandOnPlatform;

    // ========================================================================== //

    /* public - [Do] Function
     * 외부 객체가 호출(For External class call)*/

    public void DoSet_CalcaulateVerticalCollider(OnHit_VerticalCollider OnHit_VerticalCollider)
    {
        _OnHit_VerticalCollider = OnHit_VerticalCollider;
    }

    public void DoSet_OnChangeFaceDir(System.Action<int> OnChangeFaceDir)
    {
        p_pCollisionInfo.DoSet_OnChangeFaceDir(OnChangeFaceDir);
    }
    
    public void DoSet_OnChangeSlopeSliding(System.Action<bool> OnChangeSlopeSliding)
    {
        p_pCollisionInfo.DoSet_OnChangeSlopeSliding(OnChangeSlopeSliding);
    }

    public void DoSet_OnChangeStandOnPlatform(System.Action<bool> OnChangeStandOnPlatform)
    {
        _OnChangeStandOnPlatform = OnChangeStandOnPlatform;
    }

    public void DoMove(Vector2 moveAmount, bool standingOnPlatform)
    {
        DoMove(moveAmount, Vector2.zero, standingOnPlatform);
    }

    public void DoMove(Vector2 moveAmount, Vector2 input, bool standingOnPlatform = false)
    {
        DoUpdateRaycastOrigins();

        p_pCollisionInfo.Reset();
        p_pCollisionInfo.moveAmountOld = moveAmount;
        playerInput = input;

        if (moveAmount.y < 0)
        {
            if(p_eDimensionType == EDimensionType.TwoD)
                DescendSlope2D(ref moveAmount);
            else
                DescendSlope3D(ref moveAmount);
        }

        if (moveAmount.x != 0)
        {
            p_pCollisionInfo.DoSetFaceDir_OneIsLeft((int)Mathf.Sign(moveAmount.x));
        }

        HorizontalCollisions(ref moveAmount);
        if (moveAmount.y != 0)
        {
            VerticalCollisions(ref moveAmount);
        }

        transform.Translate(moveAmount);

        if (standingOnPlatform)
        {
            p_pCollisionInfo.below = true;
        }
    }

    public void DoIgnoreCollider(float fRestoreSeconds)
    {
        p_pCollisionInfo.fallingThroughPlatform = true;
        Invoke("ResetFallingThroughPlatform", fRestoreSeconds);
    }
    
    // ========================================================================== //

    /* protected - Override & Unity API         */

    protected override void OnAwake()
    {
        base.OnAwake();

        p_pCollisionInfo._listHitTransform = new List<Transform>();
        p_pCollisionInfo.DoSetFaceDir_OneIsLeft(p_iFaceDir_OnAwake);
    }

#if UNITY_EDITOR
    Vector3 vecDebugOffset = new Vector2(1f, 1f);

    private void OnDrawGizmos()
    {
        if (bDebugMode == false) return;

        Vector3 vecPos = transform.position + vecDebugOffset;
        UnityEditor.Handles.Label(vecPos, "SlopeAngle_Last : " + _fSlopeAngle_Last);

        vecPos.y -= 0.5f;
        UnityEditor.Handles.Label(vecPos, "collisions.climbingSlope : " + p_pCollisionInfo.climbingSlope);

        vecPos.y -= 0.5f;
        UnityEditor.Handles.Label(vecPos, "_pCollisionInfo.slidingDownMaxSlope : " + p_pCollisionInfo.slidingDownMaxSlope);

        vecPos.y -= 0.5f;
        UnityEditor.Handles.Label(vecPos, "_iVerticalHitCount : " + _iVerticalHitCount);
    }
#endif

    /* protected - [abstract & virtual]         */


    // ========================================================================== //

    #region Private

    void HorizontalCollisions(ref Vector2 moveAmount)
    {
        float directionX = p_pCollisionInfo.iFaceDir_OneIsLeft;
        float rayLength = Mathf.Abs(moveAmount.x) + const_fSkinWidth;

        if (Mathf.Abs(moveAmount.x) < const_fSkinWidth)
        {
            rayLength = const_fSkinWidth * 2f;
        }

        _iHorizontalHitCount = 0;

        if(p_eDimensionType == EDimensionType.TwoD)
            moveAmount = HorizontalCollision2D(moveAmount, directionX, rayLength);
        else
            moveAmount = HorizontalCollision3D(moveAmount, directionX, rayLength);
    }

    private Vector2 HorizontalCollision2D(Vector2 moveAmount, float directionX, float rayLength)
    {
        for (int i = 0; i < _iHorizontalRayCount; i++)
        {
            if (i < _iIgnoreRayCount_Horizontal)
                continue;

            Vector2 rayOrigin = (directionX == -1) ? _pRaycastOrigins.bottomLeft : _pRaycastOrigins.bottomRight;
            rayOrigin += Vector2.up * (_fHorizontalRaySpacing * i);
            RaycastHit2D hit = Physics2D.Raycast(rayOrigin, Vector2.right * directionX, rayLength, collisionMask);

            if (hit)
            {
                Debug.DrawRay(rayOrigin, Vector2.right * directionX * rayLength, Color.green);
                Debug.DrawRay(rayOrigin, hit.normal, Color.yellow);
            }
            else
                Debug.DrawRay(rayOrigin, Vector2.right * directionX * rayLength, Color.red);

            if (hit)
            {
                p_pCollisionInfo._listHitTransform.Add(hit.transform);
                _iHorizontalHitCount++;
                if (hit.distance == 0)
                {
                    continue;
                }
                _fSlopeAngle_Last = Vector2.Angle(hit.normal, Vector2.up);

                if (i == 0 && _fSlopeAngle_Last <= maxSlopeAngle)
                {
                    if (p_pCollisionInfo.descendingSlope)
                    {
                        p_pCollisionInfo.descendingSlope = false;
                        moveAmount = p_pCollisionInfo.moveAmountOld;
                    }
                    float distanceToSlopeStart = 0;
                    if (_fSlopeAngle_Last != p_pCollisionInfo.slopeAngleOld)
                    {
                        distanceToSlopeStart = hit.distance - const_fSkinWidth;
                        moveAmount.x -= distanceToSlopeStart * directionX;
                    }
                    ClimbSlope(ref moveAmount, _fSlopeAngle_Last, hit.normal);
                    moveAmount.x += distanceToSlopeStart * directionX;
                }

                if (!p_pCollisionInfo.climbingSlope || _fSlopeAngle_Last > maxSlopeAngle)
                {
                    moveAmount.x = (hit.distance - const_fSkinWidth) * directionX;
                    //rayLength = hit.distance;

                    if (p_pCollisionInfo.climbingSlope)
                    {
                        moveAmount.y = Mathf.Tan(p_pCollisionInfo.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(moveAmount.x);
                    }

                    p_pCollisionInfo.left = directionX == -1;
                    p_pCollisionInfo.right = directionX == 1;
                }
            }
        }

        return moveAmount;
    }

    private Vector2 HorizontalCollision3D(Vector2 moveAmount, float directionX, float rayLength)
    {
        for (int i = 0; i < _iHorizontalRayCount; i++)
        {
            if (i < _iIgnoreRayCount_Horizontal)
                continue;

            Vector2 rayOrigin = (directionX == -1) ? _pRaycastOrigins.bottomLeft : _pRaycastOrigins.bottomRight;
            rayOrigin += Vector2.up * (_fHorizontalRaySpacing * i);
            RaycastHit hit;
            bool bIsHit = Physics.Raycast(new Ray(rayOrigin, Vector2.right * directionX), out hit, rayLength, collisionMask);

            if (bIsHit)
            {
                Debug.DrawRay(rayOrigin, Vector2.right * directionX * rayLength, Color.green);
                Debug.DrawRay(rayOrigin, hit.normal, Color.yellow);
            }
            else
                Debug.DrawRay(rayOrigin, Vector2.right * directionX * rayLength, Color.red);

            if (bIsHit)
            {
                p_pCollisionInfo._listHitTransform.Add(hit.transform);
                _iHorizontalHitCount++;
                if (hit.distance == 0)
                {
                    continue;
                }
                _fSlopeAngle_Last = Vector2.Angle(hit.normal, Vector2.up);

                if (i == 0 && _fSlopeAngle_Last <= maxSlopeAngle)
                {
                    if (p_pCollisionInfo.descendingSlope)
                    {
                        p_pCollisionInfo.descendingSlope = false;
                        moveAmount = p_pCollisionInfo.moveAmountOld;
                    }
                    float distanceToSlopeStart = 0;
                    if (_fSlopeAngle_Last != p_pCollisionInfo.slopeAngleOld)
                    {
                        distanceToSlopeStart = hit.distance - const_fSkinWidth;
                        moveAmount.x -= distanceToSlopeStart * directionX;
                    }
                    ClimbSlope(ref moveAmount, _fSlopeAngle_Last, hit.normal);
                    moveAmount.x += distanceToSlopeStart * directionX;
                }

                if (!p_pCollisionInfo.climbingSlope || _fSlopeAngle_Last > maxSlopeAngle)
                {
                    moveAmount.x = (hit.distance - const_fSkinWidth) * directionX;
                    //rayLength = hit.distance;

                    if (p_pCollisionInfo.climbingSlope)
                    {
                        moveAmount.y = Mathf.Tan(p_pCollisionInfo.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(moveAmount.x);
                    }

                    p_pCollisionInfo.left = directionX == -1;
                    p_pCollisionInfo.right = directionX == 1;
                }
            }
        }

        return moveAmount;
    }

    void VerticalCollisions(ref Vector2 moveAmount)
    {
        float directionY = Mathf.Sign(moveAmount.y);
        float rayLength = Mathf.Abs(moveAmount.y) + const_fSkinWidth;

        _iVerticalHitCount = 0;

        if(p_eDimensionType == EDimensionType.TwoD)
            moveAmount = VerticalCollision2D(moveAmount, directionY, rayLength);
        else
            moveAmount = VerticalCollision3D(moveAmount, directionY, rayLength);

        if (p_pCollisionInfo.climbingSlope)
        {
            float directionX = Mathf.Sign(moveAmount.x);
            rayLength = Mathf.Abs(moveAmount.x) + const_fSkinWidth;
            Vector2 rayOrigin = ((directionX == -1) ? _pRaycastOrigins.bottomLeft : _pRaycastOrigins.bottomRight) + Vector2.up * moveAmount.y;

            if(p_eDimensionType == EDimensionType.TwoD)
                CalculateClimbSlope2D(rayOrigin, directionX, rayLength, ref moveAmount);
            else
                CalculateClimbSlope3D(rayOrigin, directionX, rayLength, ref moveAmount);
        }

        bool bIsStandOnPlatform = _iVerticalHitCount != 0;
        SetStandOnPlatform(bIsStandOnPlatform);
        //if (bIsStandOnPlatform)
        //    moveAmount.y = 0f;
        // else 
        if (bIsStandOnPlatform == false)
            p_pCollisionInfo.DoSetSlopeSliding(false);

    }

    private Vector2 VerticalCollision2D(Vector2 moveAmount, float directionY, float rayLength)
    {
        bool bDirectionIsLeft = p_pCollisionInfo.iFaceDir_OneIsLeft == 1;
        for (int i = 0; i < _iVerticalRayCount; i++)
        {
            if (bDirectionIsLeft && i < _iIgnoreRayCount_Vertical)
                continue;

            if (bDirectionIsLeft == false && i > _iVerticalRayCount - _iIgnoreRayCount_Vertical)
                continue;

            Vector2 rayOrigin = (directionY == -1) ? _pRaycastOrigins.bottomLeft : _pRaycastOrigins.topLeft;
            rayOrigin += Vector2.right * (_fVerticalRaySpacing * i + moveAmount.x);
            RaycastHit2D hit = Physics2D.Raycast(rayOrigin, Vector2.up * directionY, rayLength, collisionMask);

            if (hit)
            {
                Debug.DrawRay(rayOrigin, Vector2.up * directionY * rayLength, Color.green);
                Debug.DrawRay(rayOrigin, hit.normal, Color.yellow);
            }
            else
                Debug.DrawRay(rayOrigin, Vector2.up * directionY * rayLength, Color.red);

            if (hit)
            {
                ECollisionIgnoreType eIgnoreType = ECollisionIgnoreType.None;
                if (p_pCollisionInfo.fallingThroughPlatform)
                    continue;

                if (_OnHit_VerticalCollider != null)
                {
                    _OnHit_VerticalCollider(hit.transform, out eIgnoreType);
                }
                else
                {
                    if (hit.collider.CompareTag("Through"))
                    {
                        if (directionY == 1 || hit.distance == 0)
                            eIgnoreType = ECollisionIgnoreType.Though_Up;
                        if (playerInput.y == -1)
                            eIgnoreType = ECollisionIgnoreType.Though_Down;
                    }
                }

                if (eIgnoreType != ECollisionIgnoreType.None)
                {
                    switch (eIgnoreType)
                    {
                        case ECollisionIgnoreType.Though_Up:
                            break;
                        case ECollisionIgnoreType.Though_Down:
                            DoIgnoreCollider(0.5f);
                            break;
                    }
                    continue;
                }

                p_pCollisionInfo._listHitTransform.Add(hit.transform);
                _iVerticalHitCount++;
                moveAmount.y = (hit.distance - const_fSkinWidth) * directionY;
                //rayLength = hit.distance;

                if (p_pCollisionInfo.climbingSlope)
                {
                    moveAmount.x = moveAmount.y / Mathf.Tan(p_pCollisionInfo.slopeAngle * Mathf.Deg2Rad) * Mathf.Sign(moveAmount.x);
                }

                p_pCollisionInfo.below = directionY == -1;
                p_pCollisionInfo.above = directionY == 1;
            }
        }

        return moveAmount;
    }

    private Vector2 VerticalCollision3D(Vector2 moveAmount, float directionY, float rayLength)
    {
        bool bDirectionIsLeft = p_pCollisionInfo.iFaceDir_OneIsLeft == 1;
        for (int i = 0; i < _iVerticalRayCount; i++)
        {
            if (bDirectionIsLeft && i > _iVerticalRayCount - _iIgnoreRayCount_Vertical)
                continue;

            if (bDirectionIsLeft == false && i < _iIgnoreRayCount_Vertical)
                continue;

            Vector2 rayOrigin = (directionY == -1) ? _pRaycastOrigins.bottomLeft : _pRaycastOrigins.topLeft;
            rayOrigin += Vector2.right * (_fVerticalRaySpacing * i + moveAmount.x);
            RaycastHit hit;
            bool bIsHit = Physics.Raycast(new Ray(rayOrigin, Vector2.up * directionY), out hit, rayLength, collisionMask);

            if (bIsHit)
            {
                Debug.DrawRay(rayOrigin, Vector2.up * directionY * rayLength, Color.green);
                Debug.DrawRay(rayOrigin, hit.normal, Color.yellow);
            }
            else
                Debug.DrawRay(rayOrigin, Vector2.up * directionY * rayLength, Color.red);

            if (bIsHit)
            {
                ECollisionIgnoreType eIgnoreType = ECollisionIgnoreType.None;
                if (p_pCollisionInfo.fallingThroughPlatform)
                    continue;

                if (_OnHit_VerticalCollider != null)
                {
                    _OnHit_VerticalCollider(hit.transform, out eIgnoreType);
                }
                else
                {
                    if (hit.collider.CompareTag("Through"))
                    {
                        if (directionY == 1 || hit.distance == 0)
                            eIgnoreType = ECollisionIgnoreType.Though_Up;
                        if (playerInput.y == -1)
                            eIgnoreType = ECollisionIgnoreType.Though_Down;
                    }
                }

                if (eIgnoreType != ECollisionIgnoreType.None)
                {
                    switch (eIgnoreType)
                    {
                        case ECollisionIgnoreType.Though_Up:
                            break;
                        case ECollisionIgnoreType.Though_Down:
                            DoIgnoreCollider(0.5f);
                            break;
                    }
                    continue;
                }

                p_pCollisionInfo._listHitTransform.Add(hit.transform);
                _iVerticalHitCount++;
                moveAmount.y = (hit.distance - const_fSkinWidth) * directionY;
                //rayLength = hit.distance;

                if (p_pCollisionInfo.climbingSlope)
                {
                    moveAmount.x = moveAmount.y / Mathf.Tan(p_pCollisionInfo.slopeAngle * Mathf.Deg2Rad) * Mathf.Sign(moveAmount.x);
                }

                p_pCollisionInfo.below = directionY == -1;
                p_pCollisionInfo.above = directionY == 1;
            }
        }

        return moveAmount;
    }

    void CalculateClimbSlope2D(Vector2 rayOrigin, float directionX, float rayLength, ref Vector2 moveAmount)
    {
        RaycastHit2D hit = Physics2D.Raycast(rayOrigin, Vector2.right * directionX, rayLength, collisionMask);
        if (hit)
        {
            float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
            if (slopeAngle != p_pCollisionInfo.slopeAngle)
            {
                moveAmount.x = (hit.distance - const_fSkinWidth) * directionX;
                p_pCollisionInfo.slopeAngle = slopeAngle;
                p_pCollisionInfo.slopeNormal = hit.normal;
            }
        }
    }

    void CalculateClimbSlope3D(Vector2 rayOrigin, float directionX, float rayLength, ref Vector2 moveAmount)
    {
        RaycastHit hit;
        bool bIsHit = Physics.Raycast(new Ray(rayOrigin, Vector2.right * directionX), out hit, rayLength, collisionMask);
        if (bIsHit)
        {
            float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
            if (slopeAngle != p_pCollisionInfo.slopeAngle)
            {
                moveAmount.x = (hit.distance - const_fSkinWidth) * directionX;
                p_pCollisionInfo.slopeAngle = slopeAngle;
                p_pCollisionInfo.slopeNormal = hit.normal;
            }
        }
    }


    void ClimbSlope(ref Vector2 moveAmount, float slopeAngle, Vector2 slopeNormal)
    {
        float moveDistance = Mathf.Abs(moveAmount.x);
        float climbmoveAmountY = Mathf.Sin(slopeAngle * Mathf.Deg2Rad) * moveDistance;

        if (moveAmount.y <= climbmoveAmountY)
        {
            moveAmount.y = climbmoveAmountY;
            moveAmount.x = Mathf.Cos(slopeAngle * Mathf.Deg2Rad) * moveDistance * Mathf.Sign(moveAmount.x);
            p_pCollisionInfo.below = true;
            p_pCollisionInfo.climbingSlope = true;
            p_pCollisionInfo.slopeAngle = slopeAngle;
            p_pCollisionInfo.slopeNormal = slopeNormal;
        }
    }

    void DescendSlope2D(ref Vector2 moveAmount)
    {
        RaycastHit2D maxSlopeHitLeft = Physics2D.Raycast(_pRaycastOrigins.bottomLeft, Vector2.down, Mathf.Abs(moveAmount.y) + const_fSkinWidth, collisionMask);
        RaycastHit2D maxSlopeHitRight = Physics2D.Raycast(_pRaycastOrigins.bottomRight, Vector2.down, Mathf.Abs(moveAmount.y) + const_fSkinWidth, collisionMask);
        if (maxSlopeHitLeft ^ maxSlopeHitRight)
        {
            SlideDownMaxSlope2D(maxSlopeHitLeft, ref moveAmount);
            SlideDownMaxSlope2D(maxSlopeHitRight, ref moveAmount);
        }

        if (!p_pCollisionInfo.slidingDownMaxSlope)
        {
            float directionX = Mathf.Sign(moveAmount.x);
            Vector2 rayOrigin = (directionX == -1) ? _pRaycastOrigins.bottomRight : _pRaycastOrigins.bottomLeft;
            RaycastHit2D hit = Physics2D.Raycast(rayOrigin, -Vector2.up, Mathf.Infinity, collisionMask);

            if (hit)
            {
                float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
                if (slopeAngle != 0 && slopeAngle <= maxSlopeAngle)
                {
                    if (Mathf.Sign(hit.normal.x) == directionX)
                    {
                        if (hit.distance - const_fSkinWidth <= Mathf.Tan(slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(moveAmount.x))
                        {
                            float moveDistance = Mathf.Abs(moveAmount.x);
                            float descendmoveAmountY = Mathf.Sin(slopeAngle * Mathf.Deg2Rad) * moveDistance;
                            moveAmount.x = Mathf.Cos(slopeAngle * Mathf.Deg2Rad) * moveDistance * Mathf.Sign(moveAmount.x);
                            moveAmount.y -= descendmoveAmountY;

                            p_pCollisionInfo.slopeAngle = slopeAngle;
                            p_pCollisionInfo.descendingSlope = true;
                            p_pCollisionInfo.below = true;
                            p_pCollisionInfo.slopeNormal = hit.normal;
                        }
                    }
                }
            }
        }
    }

    void DescendSlope3D(ref Vector2 moveAmount)
    {
        RaycastHit maxSlopeHitLeft;
        RaycastHit maxSlopeHitRight;
        bool bHit_maxSlopLeft = Physics.Raycast(new Ray(_pRaycastOrigins.bottomLeft, Vector2.down), out maxSlopeHitLeft, Mathf.Abs(moveAmount.y) + const_fSkinWidth, collisionMask);
        bool bHit_maxSlopRight = Physics.Raycast(new Ray(_pRaycastOrigins.bottomRight, Vector2.down), out maxSlopeHitRight, Mathf.Abs(moveAmount.y) + const_fSkinWidth, collisionMask);
        if (bHit_maxSlopLeft ^ bHit_maxSlopRight)
        {
            SlideDownMaxSlope3D(bHit_maxSlopLeft, maxSlopeHitLeft, ref moveAmount);
            SlideDownMaxSlope3D(bHit_maxSlopRight, maxSlopeHitRight, ref moveAmount);
        }

        if (!p_pCollisionInfo.slidingDownMaxSlope)
        {
            float directionX = Mathf.Sign(moveAmount.x);
            Vector2 rayOrigin = (directionX == -1) ? _pRaycastOrigins.bottomRight : _pRaycastOrigins.bottomLeft;
            RaycastHit hit;
            bool bIsHit = Physics.Raycast(new Ray(rayOrigin, -Vector2.up), out hit, Mathf.Infinity, collisionMask);

            if (bIsHit)
            {
                float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
                if (slopeAngle != 0 && slopeAngle <= maxSlopeAngle)
                {
                    if (Mathf.Sign(hit.normal.x) == directionX)
                    {
                        if (hit.distance - const_fSkinWidth <= Mathf.Tan(slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(moveAmount.x))
                        {
                            float moveDistance = Mathf.Abs(moveAmount.x);
                            float descendmoveAmountY = Mathf.Sin(slopeAngle * Mathf.Deg2Rad) * moveDistance;
                            moveAmount.x = Mathf.Cos(slopeAngle * Mathf.Deg2Rad) * moveDistance * Mathf.Sign(moveAmount.x);
                            moveAmount.y -= descendmoveAmountY;

                            p_pCollisionInfo.slopeAngle = slopeAngle;
                            p_pCollisionInfo.descendingSlope = true;
                            p_pCollisionInfo.below = true;
                            p_pCollisionInfo.slopeNormal = hit.normal;
                        }
                    }
                }
            }
        }
    }

    void SlideDownMaxSlope2D(RaycastHit2D hit, ref Vector2 moveAmount)
    {
        if (!hit) return;

        float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
        bool bIsSlopeSliding = slopeAngle > maxSlopeAngle;
        if (bIsSlopeSliding)
        {
            moveAmount.x = Mathf.Sign(hit.normal.x) * (Mathf.Abs(moveAmount.y) - hit.distance) / Mathf.Tan(slopeAngle * Mathf.Deg2Rad);
            p_pCollisionInfo.slopeAngle = slopeAngle;
            p_pCollisionInfo.DoSetSlopeSliding(true);
            p_pCollisionInfo.slopeNormal = hit.normal;
        }

        p_pCollisionInfo.DoSetSlopeSliding(bIsSlopeSliding);
    }

    void SlideDownMaxSlope3D(bool bIsHit, RaycastHit hit, ref Vector2 moveAmount)
    {
        if (bIsHit == false) return;

        float slopeAngle = Vector2.Angle(hit.normal, Vector2.up);
        bool bIsSlopeSliding = slopeAngle > maxSlopeAngle;
        if (bIsSlopeSliding)
        {
            moveAmount.x = Mathf.Sign(hit.normal.x) * (Mathf.Abs(moveAmount.y) - hit.distance) / Mathf.Tan(slopeAngle * Mathf.Deg2Rad);
            p_pCollisionInfo.slopeAngle = slopeAngle;
            p_pCollisionInfo.DoSetSlopeSliding(true);
            p_pCollisionInfo.slopeNormal = hit.normal;
        }

        p_pCollisionInfo.DoSetSlopeSliding(bIsSlopeSliding);
    }


    void ResetFallingThroughPlatform()
    {
        p_pCollisionInfo.fallingThroughPlatform = false;
    }

    private void SetStandOnPlatform(bool bIsStandOn)
    {
        if (_bIsStandOnPlatform != bIsStandOn)
        {
            _bIsStandOnPlatform = bIsStandOn;
            _OnChangeStandOnPlatform(bIsStandOn);
        }
    }

    #endregion Private
}